'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var PropTypes = _interopDefault(require('prop-types'));

const isUnknownObject = (raw) => {
    return raw !== null && typeof raw === 'object';
};
const isPromise = (raw) => {
    return isUnknownObject(raw) && typeof raw.then === 'function';
};
// We are using types to enforce the `stripe` prop in this lib,
// but in an untyped integration `stripe` could be anything, so we need
// to do some sanity validation to prevent type errors.
const isStripe = (raw) => {
    return (isUnknownObject(raw) &&
        typeof raw.elements === 'function' &&
        typeof raw.createToken === 'function' &&
        typeof raw.createPaymentMethod === 'function' &&
        typeof raw.confirmCardPayment === 'function');
};

const PLAIN_OBJECT_STR = '[object Object]';
const isEqual = (left, right) => {
    if (!isUnknownObject(left) || !isUnknownObject(right)) {
        return left === right;
    }
    const leftArray = Array.isArray(left);
    const rightArray = Array.isArray(right);
    if (leftArray !== rightArray)
        return false;
    const leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;
    const rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;
    if (leftPlainObject !== rightPlainObject)
        return false;
    if (!leftPlainObject && !leftArray)
        return false;
    const leftKeys = Object.keys(left);
    const rightKeys = Object.keys(right);
    if (leftKeys.length !== rightKeys.length)
        return false;
    const keySet = {};
    for (let i = 0; i < leftKeys.length; i += 1) {
        keySet[leftKeys[i]] = true;
    }
    for (let i = 0; i < rightKeys.length; i += 1) {
        keySet[rightKeys[i]] = true;
    }
    const allKeys = Object.keys(keySet);
    if (allKeys.length !== leftKeys.length) {
        return false;
    }
    const l = left;
    const r = right;
    const pred = (key) => {
        return isEqual(l[key], r[key]);
    };
    return allKeys.every(pred);
};

const usePrevious = (value) => {
    const ref = React.useRef(value);
    React.useEffect(() => {
        ref.current = value;
    }, [value]);
    return ref.current;
};

const INVALID_STRIPE_ERROR = 'Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.';
// We are using types to enforce the `stripe` prop in this lib, but in a real
// integration `stripe` could be anything, so we need to do some sanity
// validation to prevent type errors.
const validateStripe = (maybeStripe) => {
    if (maybeStripe === null || isStripe(maybeStripe)) {
        return maybeStripe;
    }
    throw new Error(INVALID_STRIPE_ERROR);
};
const parseStripeProp = (raw) => {
    if (isPromise(raw)) {
        return {
            tag: 'async',
            stripePromise: Promise.resolve(raw).then(validateStripe),
        };
    }
    const stripe = validateStripe(raw);
    if (stripe === null) {
        return { tag: 'empty' };
    }
    return { tag: 'sync', stripe };
};
const ElementsContext = React.createContext(null);
ElementsContext.displayName = 'ElementsContext';
const parseElementsContext = (ctx, useCase) => {
    if (!ctx) {
        throw new Error(`Could not find Elements context; You need to wrap the part of your app that ${useCase} in an <Elements> provider.`);
    }
    return ctx;
};
/**
 * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.
 * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.
 *
 * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.
 * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.
 * Pass the returned `Promise` to `Elements`.
 *
 * @docs https://stripe.com/docs/stripe-js/react#elements-provider
 */
const Elements = ({ stripe: rawStripeProp, options, children, }) => {
    const final = React.useRef(false);
    const isMounted = React.useRef(true);
    const parsed = React.useMemo(() => parseStripeProp(rawStripeProp), [
        rawStripeProp,
    ]);
    const [ctx, setContext] = React.useState(() => ({
        stripe: null,
        elements: null,
    }));
    const prevStripe = usePrevious(rawStripeProp);
    const prevOptions = usePrevious(options);
    if (prevStripe !== null) {
        if (prevStripe !== rawStripeProp) {
            console.warn('Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.');
        }
        if (!isEqual(options, prevOptions)) {
            console.warn('Unsupported prop change on Elements: You cannot change the `options` prop after setting the `stripe` prop.');
        }
    }
    if (!final.current) {
        if (parsed.tag === 'sync') {
            final.current = true;
            setContext({
                stripe: parsed.stripe,
                elements: parsed.stripe.elements(options),
            });
        }
        if (parsed.tag === 'async') {
            final.current = true;
            parsed.stripePromise.then((stripe) => {
                if (stripe && isMounted.current) {
                    // Only update Elements context if the component is still mounted
                    // and stripe is not null. We allow stripe to be null to make
                    // handling SSR easier.
                    setContext({
                        stripe,
                        elements: stripe.elements(options),
                    });
                }
            });
        }
    }
    React.useEffect(() => {
        return () => {
            isMounted.current = false;
        };
    }, []);
    return (React.createElement(ElementsContext.Provider, { value: ctx }, children));
};
Elements.propTypes = {
    stripe: PropTypes.any,
    options: PropTypes.object,
};
const useElementsContextWithUseCase = (useCaseMessage) => {
    const ctx = React.useContext(ElementsContext);
    return parseElementsContext(ctx, useCaseMessage);
};
/**
 * @docs https://stripe.com/docs/stripe-js/react#useelements-hook
 */
const useElements = () => {
    const { elements } = useElementsContextWithUseCase('calls useElements()');
    return elements;
};
/**
 * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook
 */
const useStripe = () => {
    const { stripe } = useElementsContextWithUseCase('calls useStripe()');
    return stripe;
};
/**
 * @docs https://stripe.com/docs/stripe-js/react#elements-consumer
 */
const ElementsConsumer = ({ children, }) => {
    const ctx = useElementsContextWithUseCase('mounts <ElementsConsumer>');
    // Assert to satsify the busted React.FC return type (it should be ReactNode)
    return children(ctx);
};
ElementsConsumer.propTypes = {
    children: PropTypes.func.isRequired,
};

const useCallbackReference = (cb) => {
    const ref = React.useRef(cb);
    React.useEffect(() => {
        ref.current = cb;
    }, [cb]);
    return (...args) => {
        if (ref.current) {
            ref.current(...args);
        }
    };
};

const extractUpdateableOptions = (options) => {
    if (!isUnknownObject(options)) {
        return {};
    }
    const { paymentRequest: _, ...rest } = options;
    return rest;
};
const noop = () => { };
const capitalized = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const createElementComponent = (type, isServer) => {
    const displayName = `${capitalized(type)}Element`;
    const ClientElement = ({ id, className, options = {}, onBlur = noop, onFocus = noop, onReady = noop, onChange = noop, onClick = noop, }) => {
        const { elements } = useElementsContextWithUseCase(`mounts <${displayName}>`);
        const elementRef = React.useRef(null);
        const domNode = React.useRef(null);
        const callOnReady = useCallbackReference(onReady);
        const callOnBlur = useCallbackReference(onBlur);
        const callOnFocus = useCallbackReference(onFocus);
        const callOnClick = useCallbackReference(onClick);
        const callOnChange = useCallbackReference(onChange);
        React.useLayoutEffect(() => {
            if (elementRef.current == null && elements && domNode.current != null) {
                const element = elements.create(type, options);
                elementRef.current = element;
                element.mount(domNode.current);
                element.on('ready', () => callOnReady(element));
                element.on('change', callOnChange);
                element.on('blur', callOnBlur);
                element.on('focus', callOnFocus);
                // Users can pass an an onClick prop on any Element component
                // just as they could listen for the `click` event on any Element,
                // but only the PaymentRequestButton will actually trigger the event.
                element.on('click', callOnClick);
            }
        });
        const prevOptions = React.useRef(options);
        React.useEffect(() => {
            if (prevOptions.current &&
                prevOptions.current.paymentRequest !== options.paymentRequest) {
                console.warn('Unsupported prop change: options.paymentRequest is not a customizable property.');
            }
            const updateableOptions = extractUpdateableOptions(options);
            if (Object.keys(updateableOptions).length !== 0 &&
                !isEqual(updateableOptions, extractUpdateableOptions(prevOptions.current))) {
                if (elementRef.current) {
                    elementRef.current.update(updateableOptions);
                    prevOptions.current = options;
                }
            }
        }, [options]);
        React.useEffect(() => () => {
            if (elementRef.current) {
                elementRef.current.destroy();
            }
        }, []);
        return React.createElement("div", { id: id, className: className, ref: domNode });
    };
    // Only render the Element wrapper in a server environment.
    const ServerElement = (props) => {
        // Validate that we are in the right context by calling useElementsContextWithUseCase.
        useElementsContextWithUseCase(`mounts <${displayName}>`);
        const { id, className } = props;
        return React.createElement("div", { id: id, className: className });
    };
    const Element = isServer ? ServerElement : ClientElement;
    Element.propTypes = {
        id: PropTypes.string,
        className: PropTypes.string,
        onChange: PropTypes.func,
        onBlur: PropTypes.func,
        onFocus: PropTypes.func,
        onReady: PropTypes.func,
        onClick: PropTypes.func,
        options: PropTypes.object,
    };
    Element.displayName = displayName;
    Element.__elementType = type;
    return Element;
};

const isServer = typeof window === 'undefined';
/**
 * Requires beta access:
 * Contact [Stripe support](https://support.stripe.com/) for more information.
 *
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const AuBankAccountElement = createElementComponent('auBankAccount', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const CardElement = createElementComponent('card', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const CardNumberElement = createElementComponent('cardNumber', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const CardExpiryElement = createElementComponent('cardExpiry', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const CardCvcElement = createElementComponent('cardCvc', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const FpxBankElement = createElementComponent('fpxBank', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const IbanElement = createElementComponent('iban', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const IdealBankElement = createElementComponent('idealBank', isServer);
/**
 * @docs https://stripe.com/docs/stripe-js/react#element-components
 */
const PaymentRequestButtonElement = createElementComponent('paymentRequestButton', isServer);

exports.AuBankAccountElement = AuBankAccountElement;
exports.CardCvcElement = CardCvcElement;
exports.CardElement = CardElement;
exports.CardExpiryElement = CardExpiryElement;
exports.CardNumberElement = CardNumberElement;
exports.Elements = Elements;
exports.ElementsConsumer = ElementsConsumer;
exports.FpxBankElement = FpxBankElement;
exports.IbanElement = IbanElement;
exports.IdealBankElement = IdealBankElement;
exports.PaymentRequestButtonElement = PaymentRequestButtonElement;
exports.useElements = useElements;
exports.useStripe = useStripe;
